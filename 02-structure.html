<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>tui.rs - async-template</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">
        <link rel="stylesheet" href="./theme/catppuccin.css">
        <link rel="stylesheet" href="./theme/catppuccin-highlight.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Home</a></li><li class="chapter-item expanded "><a href="00-structure.html"><strong aria-hidden="true">2.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-structure.html"><strong aria-hidden="true">2.1.</strong> main.rs</a></li><li class="chapter-item expanded "><a href="02-structure.html" class="active"><strong aria-hidden="true">2.2.</strong> tui.rs</a></li><li class="chapter-item expanded "><a href="03-structure.html"><strong aria-hidden="true">2.3.</strong> action.rs</a></li><li class="chapter-item expanded "><a href="04-structure.html"><strong aria-hidden="true">2.4.</strong> app.rs</a></li><li class="chapter-item expanded "><a href="05-structure.html"><strong aria-hidden="true">2.5.</strong> components.rs</a></li><li class="chapter-item expanded "><a href="06-structure.html"><strong aria-hidden="true">2.6.</strong> components/home.rs</a></li><li class="chapter-item expanded "><a href="07-structure.html"><strong aria-hidden="true">2.7.</strong> config.rs</a></li><li class="chapter-item expanded "><a href="08-structure.html"><strong aria-hidden="true">2.8.</strong> utils.rs</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappé</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">async-template</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ratatui-org/async-template" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ratatui-org/async-template/edit/main/book/src/02-structure.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tuirs"><a class="header" href="#tuirs"><code>tui.rs</code></a></h1>
<h2 id="terminal"><a class="header" href="#terminal">Terminal</a></h2>
<p>In this section of the tutorial, we are going to discuss the basic components of the <code>Tui</code> struct.</p>
<p>You’ll find most people setup and teardown of a terminal application using <code>crossterm</code> like so:</p>
<pre><code class="language-rust">fn setup_terminal() -&gt; Result&lt;Terminal&lt;CrosstermBackend&lt;Stdout&gt;&gt;&gt; {
  let mut stdout = io::stdout();
  crossterm::terminal::enable_raw_mode()?;
  crossterm::execute!(stdout, EnterAlternateScreen, EnableMouseCapture, HideCursor)?;
  Terminal::new(CrosstermBackend::new(stdout))
}

fn teardown_terminal(terminal: &amp;mut Terminal&lt;CrosstermBackend&lt;Stdout&gt;&gt;) -&gt; Result&lt;()&gt; {
  let mut stdout = io::stdout();
  crossterm::terminal::disable_raw_mode()?;
  crossterm::execute!(stdout, LeaveAlternateScreen, DisableMouseCapture, ShowCursor)?;
  Ok(())
}

fn main() -&gt; Result&lt;()&gt; {
  let mut terminal = setup_terminal()?;
  run_app(&amp;mut terminal)?;
  teardown_terminal(&amp;mut terminal)?;
  Ok(())
}</code></pre>
<p>You can use <code>termion</code> or <code>termwiz</code> instead here, and you’ll have to change the implementation of
<code>setup_terminal</code> and <code>teardown_terminal</code>.</p>
<p>I personally like to use <code>crossterm</code> so that I can run the TUI on windows as well.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="#admonition-note"></a></p>
</div>
<div>
<p>Terminals have two screen buffers for each window.
The default screen buffer is what you are dropped into when you start up a terminal.
The second screen buffer, called the alternate screen, is used for running interactive apps such as the <code>vim</code>, <code>less</code> etc.</p>
<p>Here’s a 8 minute talk on Terminal User Interfaces I gave at JuliaCon2020: <a href="https://www.youtube.com/watch?v=-TASx67pphw">https://www.youtube.com/watch?v=-TASx67pphw</a> that might be worth watching for more information about how terminal user interfaces work.</p>
</div>
</div>
<p>We can reorganize the setup and teardown functions into an <code>enter()</code> and <code>exit()</code> methods on a <code>Tui</code>
struct.</p>
<pre><code class="language-rust no_run noplayground">use color_eyre::eyre::{anyhow, Context, Result};
use crossterm::{
  cursor,
  event::{DisableMouseCapture, EnableMouseCapture},
  terminal::{EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::backend::CrosstermBackend as Backend;
use tokio::{
  sync::{mpsc, Mutex},
  task::JoinHandle,
};

pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, Backend&lt;std::io::Stderr&gt;&gt;;

pub struct Tui {
  pub terminal: ratatui::Terminal&lt;Backend&lt;std::io::Stderr&gt;&gt;,
}

impl Tui {
  pub fn new() -&gt; Result&lt;Self&gt; {
    let terminal = ratatui::Terminal::new(Backend::new(std::io::stderr()))?;
    Ok(Self { terminal })
  }

  pub fn enter(&amp;self) -&gt; Result&lt;()&gt; {
    crossterm::terminal::enable_raw_mode()?;
    crossterm::execute!(std::io::stderr(), EnterAlternateScreen, EnableMouseCapture, cursor::Hide)?;
    Ok(())
  }

  pub fn exit(&amp;self) -&gt; Result&lt;()&gt; {
    crossterm::execute!(std::io::stderr(), LeaveAlternateScreen, DisableMouseCapture, cursor::Show)?;
    crossterm::terminal::disable_raw_mode()?;
    Ok(())
  }

  pub fn suspend(&amp;self) -&gt; Result&lt;()&gt; {
    self.exit()?;
    #[cfg(not(windows))]
    signal_hook::low_level::raise(signal_hook::consts::signal::SIGTSTP)?;
    Ok(())
  }

  pub fn resume(&amp;self) -&gt; Result&lt;()&gt; {
    self.enter()?;
    Ok(())
  }
}</code></pre>
<div id="admonition-note-1" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="#admonition-note-1"></a></p>
</div>
<div>
<p>This is the same <code>Tui</code> struct we used in <code>initialize_panic_handler()</code>. We call <code>Tui::exit()</code> before printing the stacktrace.</p>
</div>
</div>
<p>Feel free to modify this as you need for use with <code>termion</code> or <code>wezterm</code>.</p>
<p>The type alias to <code>Frame</code> is only to make the <code>components</code> folder easier to work with, and is not
strictly required.</p>
<h2 id="event"><a class="header" href="#event">Event</a></h2>
<p>In it’s simplest form, most applications will have a <code>main</code> loop like this:</p>
<pre><code class="language-rust">fn main() -&gt; Result&lt;()&gt; {
  let mut app = App::new();

  let mut t = Tui::new()?;

  t.enter()?; // raw mode enabled

  loop {

    // get key event and update state
    // ... Special handling to read key or mouse events required here

    t.terminal.draw(|f| { // &lt;- `terminal.draw` is the only ratatui function here
      ui(app, f) // render state to terminal
    })?;

  }

  t.exit()?; // raw mode disabled

  Ok(())
}</code></pre>
<div id="admonition-note-2" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="#admonition-note-2"></a></p>
</div>
<div>
<p>The <code>terminal.draw(|f| { ui(app, f); })</code> call is the only line in the code above
that uses <code>ratatui</code> functionality.
You can learn more about
<a href="https://docs.rs/ratatui/latest/ratatui/terminal/struct.Terminal.html#method.draw"><code>draw</code> from the official documentation</a>.
Essentially, <code>terminal.draw()</code> takes a callback that takes a
<a href="https://docs.rs/ratatui/latest/ratatui/terminal/struct.Frame.html"><code>Frame</code></a> and expects
the callback to render widgets to that frame, which is then drawn to the terminal
using a double buffer technique.</p>
</div>
</div>
<p>While we are in the “raw mode”, i.e. after we call <code>t.enter()</code>, any key presses in that terminal
window are sent to <code>stdin</code>. We have to read these key presses from <code>stdin</code> if we want to act on
them.</p>
<p>There’s a number of different ways to do that. <code>crossterm</code> has a <code>event</code> module that implements
features to read these key presses for us.</p>
<p>Let’s assume we were building a simple “counter” application, that incremented a counter when we
pressed <code>j</code> and decremented a counter when we pressed <code>k</code>.</p>
<pre><code class="language-rust">fn main() -&gt; Result {
  let mut app = App::new();

  let mut t = Tui::new()?;

  t.enter()?;

  loop {
    if crossterm::event::poll(Duration::from_millis(250))? {
      if let Event::Key(key) = crossterm::event::read()? {
        match key.code {
          KeyCode::Char('j') =&gt; app.increment(),
          KeyCode::Char('k') =&gt; app.decrement(),
          KeyCode::Char('q') =&gt; break,
          _ =&gt; (),
        }
      }
    };

    t.terminal.draw(|f| {
      ui(app, f)
    })?;
  }

  t.exit()?;

  Ok(())
}</code></pre>
<p>This works perfectly fine, and a lot of small to medium size programs can get away with doing just
that.</p>
<p>However, this approach conflates the key input handling with app state updates, and does so in the
“draw” loop. The practical issue with this approach is we block the draw loop for 250 ms waiting for
a key press. This can have odd side effects, for example pressing an holding a key will result in
faster draws to the terminal.</p>
<p>In terms of architecture, the code could get complicated to reason about. For example, we may even
want key presses to mean <em>different</em> things depending on the state of the app (when you are focused
on an input field, you may want to enter the letter <code>&quot;j&quot;</code> into the text input field, but when
focused on a list of items, you may want to scroll down the list.)</p>
<p><img src="https://user-images.githubusercontent.com/1813121/254444604-de8cfcfa-eeec-417a-a8b0-92a7ccb5fcb5.gif" alt="Pressing j 3 times to increment counter and 3 times in the text field" /></p>
<!--
```
Set Shell zsh
Sleep 1s
Hide
Type "cargo run"
Enter
Sleep 1s
Show
Type "jjj"
Sleep 5s
Sleep 5s
Type "/jjj"
Sleep 5s
Escape
Type "q"
```
-->
<p>We have to do a few different things set ourselves up, so let’s take things one step at a time.</p>
<p>First, instead of polling, we are going to introduce channels to get the key presses asynchronously
and send them over a channel. We will then receive on the channel in the <code>main</code> loop.</p>
<p>There are two ways to do this. We can either use OS threads or “green” threads, i.e. tasks, i.e.
rust’s <code>async</code>-<code>await</code> features + a future executor.</p>
<p>Here’s example code of reading key presses asynchronously using <code>std::thread</code> and <code>tokio::task</code>.</p>
<h2 id="stdthread"><a class="header" href="#stdthread"><code>std::thread</code></a></h2>
<pre><code class="language-rust">enum Event {
  Key(crossterm::event::KeyEvent)
}

struct EventHandler {
  rx: std::sync::mpsc::Receiver&lt;Event&gt;,
}

impl EventHandler {
  fn new() -&gt; Self {
    let tick_rate = std::time::Duration::from_millis(250);
    let (tx, rx) =  std::sync::mpsc::channel();
    std::thread::spawn(move || {
      loop {
        if crossterm::event::poll(tick_rate)? {
          match crossterm::event::read()? {
            CrosstermEvent::Key(e) =&gt; tx.send(Event::Key(e)),
            _ =&gt; unimplemented!(),
          }?
        }
      }
    })

    EventHandler { rx }
  }

  fn next(&amp;self) -&gt; Result&lt;Event&gt; {
    Ok(self.rx.recv()?)
  }
}</code></pre>
<h2 id="tokiotask"><a class="header" href="#tokiotask"><code>tokio::task</code></a></h2>
<pre><code class="language-rust">enum Event {
  Key(crossterm::event::KeyEvent)
}

struct EventHandler {
  rx: tokio::sync::mpsc::UnboundedReceiver&lt;Event&gt;,
}

impl EventHandler {
  fn new() -&gt; Self {
    let tick_rate = std::time::Duration::from_millis(250);
    let (tx, mut rx) =  tokio::sync::mpsc::unbounded_channel();
    tokio::spawn(async move {
      loop {
        if crossterm::event::poll(tick_rate)? {
          match crossterm::event::read()? {
            CrosstermEvent::Key(e) =&gt; tx.send(Event::Key(e)),
            _ =&gt; unimplemented!(),
          }?
        }
      }
    })

    EventHandler { rx }
  }

  async fn next(&amp;self) -&gt; Result&lt;Event&gt; {
    Ok(self.rx.recv().await.ok()?)
  }
}</code></pre>
<h2 id="diff"><a class="header" href="#diff"><code>diff</code></a></h2>
<pre><code class="language-diff">  enum Event {
    Key(crossterm::event::KeyEvent)
  }

  struct EventHandler {
-   rx: std::sync::mpsc::Receiver&lt;Event&gt;,
+   rx: tokio::sync::mpsc::UnboundedReceiver&lt;Event&gt;,
  }

  impl EventHandler {
    fn new() -&gt; Self {
      let tick_rate = std::time::Duration::from_millis(250);
-     let (tx, rx) =  std::sync::mpsc::channel();
+     let (tx, mut rx) =  tokio::sync::mpsc::unbounded_channel();
-     std::thread::spawn(move || {
+     tokio::spawn(async move {
        loop {
          if crossterm::event::poll(tick_rate)? {
            match crossterm::event::read()? {
              CrosstermEvent::Key(e) =&gt; tx.send(Event::Key(e)),
              _ =&gt; unimplemented!(),
            }?
          }
        }
      })

      EventHandler { rx }
    }

-   fn next(&amp;self) -&gt; Result&lt;Event&gt; {
+   async fn next(&amp;self) -&gt; Result&lt;Event&gt; {
-     Ok(self.rx.recv()?)
+     Ok(self.rx.recv().await.ok()?)
    }
  }
</code></pre>
<div id="admonition-warning" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="#admonition-warning"></a></p>
</div>
<div>
<p>A lot of examples out there in the wild might use the following code for sending key presses:</p>
<pre><code class="language-rust">  CrosstermEvent::Key(e) =&gt; tx.send(Event::Key(e)),</code></pre>
<p>However, on Windows, when using <code>Crossterm</code>, this will send the same <code>Event::Key(e)</code> twice; one for when you press the key, i.e. <code>KeyEventKind::Press</code> and one for when you release the key, i.e. <code>KeyEventKind::Release</code>.
On <code>MacOS</code> and <code>Linux</code> only <code>KeyEventKind::Press</code> kinds of <code>key</code> event is generated.</p>
<p>To make the code work as expected across all platforms, you can do this instead:</p>
<pre><code class="language-rust">  CrosstermEvent::Key(key) =&gt; {
    if key.kind == KeyEventKind::Press {
      event_tx.send(Event::Key(key)).unwrap();
    }
  },</code></pre>
</div>
</div>
<p>Tokio is an asynchronous runtime for the Rust programming language. It is one of the more popular
runtimes for asynchronous programming in rust. You can learn more about here
<a href="https://tokio.rs/tokio/tutorial">https://tokio.rs/tokio/tutorial</a>. For the rest of the tutorial here, we are going to assume we want
to use tokio. I highly recommend you read the official <code>tokio</code> documentation.</p>
<p>If we use <code>tokio</code>, receiving a event requires <code>.await</code>. So our <code>main</code> loop now looks like this:</p>
<pre><code class="language-rust">#[tokio::main]
async fn main() -&gt; {
  let mut app = App::new();

  let events = EventHandler::new();

  let mut t = Tui::new()?;

  t.enter()?;

  loop {
    if let Event::Key(key) = events.next().await? {
      match key.code {
        KeyCode::Char('j') =&gt; app.increment(),
        KeyCode::Char('k') =&gt; app.decrement(),
        KeyCode::Char('q') =&gt; break,
        _ =&gt; (),
      }
    }

    t.terminal.draw(|f| {
      ui(app, f)
    })?;
  }

  t.exit()?;

  Ok(())
}</code></pre>
<h3 id="additional-improvements"><a class="header" href="#additional-improvements">Additional improvements</a></h3>
<p>We are going to modify our <code>EventHandler</code> to handle a <code>AppTick</code> event. We want the <code>Event::AppTick</code>
to be sent at regular intervals. We are also going to want to use a <code>CancellationToken</code> to stop the
tokio task on request.</p>
<p><a href="https://tokio.rs/tokio/tutorial/select"><code>tokio</code>’s <code>select!</code> macro</a> allows us to wait on multiple
<code>async</code> computations and returns when a single computation completes.</p>
<p>Here’s what the completed <code>EventHandler</code> code now looks like:</p>
<pre><code class="language-rust no_run noplayground">use color_eyre::eyre::Result;
use crossterm::{
  cursor,
  event::{Event as CrosstermEvent, KeyEvent, KeyEventKind, MouseEvent},
};
use futures::{FutureExt, StreamExt};
use tokio::{
  sync::{mpsc, oneshot},
  task::JoinHandle,
};

#[derive(Clone, Copy, Debug)]
pub enum Event {
  Error,
  AppTick,
  Key(KeyEvent),
}

#[derive(Debug)]
pub struct EventHandler {
  _tx: mpsc::UnboundedSender&lt;Event&gt;,
  rx: mpsc::UnboundedReceiver&lt;Event&gt;,
  task: Option&lt;JoinHandle&lt;()&gt;&gt;,
  stop_cancellation_token: CancellationToken,
}

impl EventHandler {
  pub fn new(tick_rate: u64) -&gt; Self {
    let tick_rate = std::time::Duration::from_millis(tick_rate);

    let (tx, rx) = mpsc::unbounded_channel();
    let _tx = tx.clone();

    let stop_cancellation_token = CancellationToken::new();
    let _stop_cancellation_token = stop_cancellation_token.clone();

    let task = tokio::spawn(async move {
      let mut reader = crossterm::event::EventStream::new();
      let mut interval = tokio::time::interval(tick_rate);
      loop {
        let delay = interval.tick();
        let crossterm_event = reader.next().fuse();
        tokio::select! {
          _ = _stop_cancellation_token.cancelled() =&gt; {
            break;
          }
          maybe_event = crossterm_event =&gt; {
            match maybe_event {
              Some(Ok(evt)) =&gt; {
                match evt {
                  CrosstermEvent::Key(key) =&gt; {
                    if key.kind == KeyEventKind::Press {
                      tx.send(Event::Key(key)).unwrap();
                    }
                  },
                  _ =&gt; {},
                }
              }
              Some(Err(_)) =&gt; {
                tx.send(Event::Error).unwrap();
              }
              None =&gt; {},
            }
          },
          _ = delay =&gt; {
              tx.send(Event::AppTick).unwrap();
          },
        }
      }
    });

    Self { _tx, rx, task: Some(task), stop_cancellation_token }
  }

  pub async fn next(&amp;mut self) -&gt; Option&lt;Event&gt; {
    self.rx.recv().await
  }

  pub async fn stop(&amp;mut self) -&gt; Result&lt;()&gt; {
    self.stop_cancellation_token.cancel();
    if let Some(handle) = self.task.take() {
      handle.await.unwrap();
    }
    Ok(())
  }
}</code></pre>
<div id="admonition-note-3" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="#admonition-note-3"></a></p>
</div>
<div>
<p>Using <code>crossterm::event::EventStream::new()</code> requires the <code>event-stream</code> feature to be enabled.</p>
<pre><code class="language-yml">crossterm = { version = &quot;0.26.1&quot;, default-features = false, features = [&quot;event-stream&quot;] }
</code></pre>
</div>
</div>
<p>With this <code>EventHandler</code> implemented, we can use <code>tokio</code> to create a separate “task” that handles
any key asynchronously in our <code>main</code> loop.</p>
<p>I personally like to combine the <code>EventHandler</code> and the <code>Tui</code> struct into one struct. Here’s an
example of that <code>Tui</code> struct for your reference.</p>
<pre><code class="language-rust">use std::{
  ops::{Deref, DerefMut},
  time::Duration,
};

use color_eyre::eyre::Result;
use crossterm::{
  cursor,
  event::{Event as CrosstermEvent, KeyEvent, KeyEventKind, MouseEvent},
  terminal::{EnterAlternateScreen, LeaveAlternateScreen},
};
use futures::{FutureExt, StreamExt};
use ratatui::backend::CrosstermBackend as Backend;
use serde::{Deserialize, Serialize};
use tokio::{
  sync::mpsc::{self, UnboundedReceiver, UnboundedSender},
  task::JoinHandle,
};
use tokio_util::sync::CancellationToken;

pub type Frame&lt;'a&gt; = ratatui::Frame&lt;'a, Backend&lt;std::io::Stderr&gt;&gt;;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum Event {
  Init,
  Quit,
  Error,
  Closed,
  Tick,
  Render,
  FocusGained,
  FocusLost,
  Paste(String),
  Key(KeyEvent),
  Mouse(MouseEvent),
  Resize(u16, u16),
}

pub struct Tui {
  pub terminal: ratatui::Terminal&lt;Backend&lt;std::io::Stderr&gt;&gt;,
  pub task: JoinHandle&lt;()&gt;,
  pub cancellation_token: CancellationToken,
  pub event_rx: UnboundedReceiver&lt;Event&gt;,
  pub event_tx: UnboundedSender&lt;Event&gt;,
  pub frame_rate: f64,
  pub tick_rate: f64,
}

impl Tui {
  pub fn new() -&gt; Result&lt;Self&gt; {
    let tick_rate = 4.0;
    let frame_rate = 60.0;
    let terminal = ratatui::Terminal::new(Backend::new(std::io::stderr()))?;
    let (event_tx, event_rx) = mpsc::unbounded_channel();
    let cancellation_token = CancellationToken::new();
    let task = tokio::spawn(async {});
    Ok(Self { terminal, task, cancellation_token, event_rx, event_tx, frame_rate, tick_rate })
  }

  pub fn tick_rate(&amp;mut self, tick_rate: f64) {
    self.tick_rate = tick_rate;
  }

  pub fn frame_rate(&amp;mut self, frame_rate: f64) {
    self.frame_rate = frame_rate;
  }

  pub fn start(&amp;mut self) {
    let tick_delay = std::time::Duration::from_secs_f64(1.0 / self.tick_rate);
    let render_delay = std::time::Duration::from_secs_f64(1.0 / self.frame_rate);
    self.cancel();
    self.cancellation_token = CancellationToken::new();
    let _cancellation_token = self.cancellation_token.clone();
    let _event_tx = self.event_tx.clone();
    self.task = tokio::spawn(async move {
      let mut reader = crossterm::event::EventStream::new();
      let mut tick_interval = tokio::time::interval(tick_delay);
      let mut render_interval = tokio::time::interval(render_delay);
      _event_tx.send(Event::Init).unwrap();
      loop {
        let tick_delay = tick_interval.tick();
        let render_delay = render_interval.tick();
        let crossterm_event = reader.next().fuse();
        tokio::select! {
          _ = _cancellation_token.cancelled() =&gt; {
            break;
          }
          maybe_event = crossterm_event =&gt; {
            match maybe_event {
              Some(Ok(evt)) =&gt; {
                match evt {
                  CrosstermEvent::Key(key) =&gt; {
                    if key.kind == KeyEventKind::Press {
                      _event_tx.send(Event::Key(key)).unwrap();
                    }
                  },
                  CrosstermEvent::Mouse(mouse) =&gt; {
                    _event_tx.send(Event::Mouse(mouse)).unwrap();
                  },
                  CrosstermEvent::Resize(x, y) =&gt; {
                    _event_tx.send(Event::Resize(x, y)).unwrap();
                  },
                  CrosstermEvent::FocusLost =&gt; {
                    _event_tx.send(Event::FocusLost).unwrap();
                  },
                  CrosstermEvent::FocusGained =&gt; {
                    _event_tx.send(Event::FocusGained).unwrap();
                  },
                  CrosstermEvent::Paste(s) =&gt; {
                    _event_tx.send(Event::Paste(s)).unwrap();
                  },
                }
              }
              Some(Err(_)) =&gt; {
                _event_tx.send(Event::Error).unwrap();
              }
              None =&gt; {},
            }
          },
          _ = tick_delay =&gt; {
              _event_tx.send(Event::Tick).unwrap();
          },
          _ = render_delay =&gt; {
              _event_tx.send(Event::Render).unwrap();
          },
        }
      }
    });
  }

  pub fn stop(&amp;self) -&gt; Result&lt;()&gt; {
    self.cancel();
    let mut counter = 0;
    while !self.task.is_finished() {
      std::thread::sleep(Duration::from_millis(1));
      counter += 1;
      if counter &gt; 50 {
        self.task.abort();
      }
      if counter &gt; 100 {
        log::error!(&quot;Failed to abort task in 100 milliseconds for unknown reason&quot;);
        break;
      }
    }
    Ok(())
  }

  pub fn enter(&amp;mut self) -&gt; Result&lt;()&gt; {
    crossterm::terminal::enable_raw_mode()?;
    crossterm::execute!(std::io::stderr(), EnterAlternateScreen, cursor::Hide)?;
    self.start();
    Ok(())
  }

  pub fn exit(&amp;mut self) -&gt; Result&lt;()&gt; {
    self.stop()?;
    if crossterm::terminal::is_raw_mode_enabled()? {
      self.flush()?;
      crossterm::execute!(std::io::stderr(), LeaveAlternateScreen, cursor::Show)?;
      crossterm::terminal::disable_raw_mode()?;
    }
    Ok(())
  }

  pub fn cancel(&amp;self) {
    self.cancellation_token.cancel();
  }

  pub fn suspend(&amp;mut self) -&gt; Result&lt;()&gt; {
    self.exit()?;
    #[cfg(not(windows))]
    signal_hook::low_level::raise(signal_hook::consts::signal::SIGTSTP)?;
    Ok(())
  }

  pub fn resume(&amp;mut self) -&gt; Result&lt;()&gt; {
    self.enter()?;
    Ok(())
  }

  pub async fn next(&amp;mut self) -&gt; Option&lt;Event&gt; {
    self.event_rx.recv().await
  }
}

impl Deref for Tui {
  type Target = ratatui::Terminal&lt;Backend&lt;std::io::Stderr&gt;&gt;;

  fn deref(&amp;self) -&gt; &amp;Self::Target {
    &amp;self.terminal
  }
}

impl DerefMut for Tui {
  fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
    &amp;mut self.terminal
  }
}

impl Drop for Tui {
  fn drop(&amp;mut self) {
    self.exit().unwrap();
  }
}</code></pre>
<p>In the next section, we will introduce a <code>Command</code> pattern to bridge handling the effect of an
event.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="01-structure.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="03-structure.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="01-structure.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="03-structure.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
